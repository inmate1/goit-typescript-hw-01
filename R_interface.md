////////// Интерфейсы /////
Общее понятие

Интерфейс – это определение кастомного типа данных , но без какой-либо реализации .

В TypeScript интерфейсы играют ключевую роль в статической типизации. Они помогают обеспечить согласованность и четкость структуры объектов или классов.

Давайте рассмотрим пример интерфейса для описания типа данных Person :

interface Person {
  firstName: string;
  lastName: string;
  age?: number; // Необов'язкове поле
}

function greet(person: Person) {
  console.log(`Hello, ${person.firstName} ${person.lastName}`);
}

const john: Person = {
  firstName: 'John',
  lastName: 'Doe',
};

greet(john); // Виведе: "Hello, John Doe"

В этом примере мы определили интерфейс Person с полями firstName , lastName и необязательным полем age . Затем мы использовали этот интерфейс для типизации параметра функции greet и переменной john . Итак, мы можем быть уверены в том, что функция greet всегда будет работать с объектами, имеющими структуру, соответствующую интерфейсу Person .

// Интерфейсы объектов//

В TypeScript мы не можем использовать интерфейсы как тип данных для объектов. Расширим наш пример о самолетах, добавив пилота. Для этого создадим интерфейс IPerson :

interface IPerson {
  name: string;
  age: number;
  greet(phrase: string): void;
}

let user: IPerson;

user = {
  name: 'Anthony',
  age: 21,
  greet(phrase) {
    console.log(phrase + ' ' + this.name );
  }
};

user.greet('Вітання всім, я'); // Вітання всім, я Anthony
 
Итак, мы видим, что создали объект user типа IPerson , который успешно реализует интерфейс IPerson . И хотя этот пользователь впоследствии станет нашим капитаном, сейчас он просто Энтони.

Создание интерфейса происходит с помощью команды interface , после которой следует имя интерфейса. По общепринятой согласованности имя интерфейса начинается с прописной буквы I, а затем следует имя интерфейса, начинающегося с прописной буквы. Встречается также именование в формате PersonInterface , где очевидно указывается, что это интерфейс, но для удобства программистов частенько употребляют более маленькую форму.

Сейчас интерфейс выполняет функцию типа : он определяет, какие поля должны быть в объекте. Если попробуем добавить поле, которое нет в интерфейсе, TypeScript выдаст ошибку.

const user = {
  name: 'Anthony',
  age: 21,
  hobby: 'Flying', // Помилка: Property 'hobby' does not exist on type 'IPerson'.
}

На самом деле, если мы используем интерфейс для объекта, мало что меняется, если мы заменим interface на type .

Давайте попробуем:

type IPerson = {
  name: string;
  age: number;
  greet(phrase: string): void;
}

let user: IPerson;

user = {
  name: 'Anthony',
  age: 21,
  greet(phrase) {
    console.log(phrase + ' ' + this.name );
  },
};

И снова все работает! И все же есть разница между interface и type , особенно когда мы хотим добавить интерфейс в класс. 

///////////  Readonly Только чтение ///////

Интерфейсы позволяют использовать модификатор readonly . Этот модификатор делает свойство только для чтения, что означает, что его значение можно установить только при создании объекта и со временем нельзя изменить.
Давайте посмотрим на пример:

interface ITest {
  readonly name: string;
}

const person: ITest = {
  name: 'Person Name',
};

person.name = 'Another Name'; 
// Error: Cannot assign to 'name' because it is a read-only property.
// Ошибка: невозможно присвоить ' name', поскольку это свойство доступно только для чтения .

Попытка переназначить name приведет к ошибке компиляции. Это гарантирует, что объекты, соответствующие этому интерфейсу , будут иметь свойство name , которое нельзя изменить после их создания, что обеспечивает большую надежность кода и предотвращает случайные изменения. Этот аспект работы с интерфейсами особенно важен при работе с объектами, которые должны оставаться неизменными после создания.

//////////// Extending Interfaces Расширение интерфейсов ///////////

Одной из прекрасных возможностей, предоставляющих нам интерфейсы , является возможность расширения. Иначе говоря, один интерфейс может подражать свойствам и методам другого интерфейса с помощью ключевого слова extends . Это особенно полезно, когда у вас есть несколько объектов, разделяющих общие свойства или методы, и вы хотите избежать дублирования кода.

Давайте рассмотрим пример. У нас есть интерфейс IPerson , который описывает базовые свойства и методы, которые должен иметь каждый человек:

interface IPerson {
  name: string;
  age: number;
  greet(phrase: string): void;
}

Теперь допустим, у нас есть специфический тип людей – пилоты. Они обладают всеми свойствами и методами обычного человека, но имеют дополнительный метод flyMessage() . Вместо того чтобы переопределять все свойства и методы из IPerson в новом интерфейсе IPilot , мы можем просто расширить IPerson :

interface IPilot extends IPerson {
  flyMessage(): void;
}

Теперь интерфейс IPilot включает все свойства и методы с IPerson , а также дополнительный метод flyMessage() . Это значительно упрощает организацию и поддержку нашего кода, особенно при работе с большими и сложными объектами.

/////////// Интерфейсы как тип функции ////////

Интерфейсы могут использоваться не только для описания формы объектов, но и для определения типов функций.

Ранее мы обсуждали использование типов для определения функций, как в данном примере:

type AddFunc = (n1: number, n2: number) => number;

let add: AddFunc;

add = (n1: number, n2: number) => {
  return n1 + n2;
};
 
В этом примере AddFunc определяет функцию, принимающую два числа и возвращающую число. Мы можем использовать этот тип для аннотации переменных и гарантируем, что любая функция, которую мы присваиваем переменным, соответствует этому формату.

Но мы можем достичь такого же результата с использованием интерфейсов . Синтаксис немного отличается, но идея такая же:

interface AddFunc {
  (n1: number, n2: number): number;
}

let add: AddFunc;

add = (n1: number, n2: number) => {
  return n1 + n2;
};

В этом случае AddFunc определяется как интерфейс с одним вызываемым методом . Это, в сущности, аналогично тому, что мы делали с типами, но с использованием синтаксиса интерфейсов.

Наконец, выбор между использованием типов или интерфейсов часто сводится к преимуществам стиля или конкретным требованиям проекта. Оба подхода работают одинаково хорошо для определения типов функций.

///////////  Опциональные свойства ////////

Интерфейсы могут включать опциональные свойства , позволяющие создать более гибкие и универсальные типы. Все, что нужно сделать, это добавить вопросительный знак (?) после имени свойства в определении интерфейса.

Возьмем такой пример:
interface IPerson {
  name?: string;
  age: number;
}

Здесь name является опциональным свойством интерфейса IPerson. Это означает, что объекты, соответствующие этому интерфейсу, могут содержать или не содержать свойства name.

Теперь, когда мы реализуем этот интерфейс, мы можем обозначить name как опциональное свойство .

interface IPerson {
  name?: string;
  age: number;
}

const mango: IPerson = {
  name: "mango",
	age: 2
}

const poly: IPerson = {
	age: 5
}

Поскольку name – опциональное свойство , мы можем ее вообще не указывать в объекте, и это не вызовет ошибку.