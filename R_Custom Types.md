////////// Custom Types /////////
Custom Types , или типы пользовательских данных, — это мощный инструмент в TypeScript, позволяющий вам определять собственные структуры данных. Мы уже описывали свои типы, но давайте погрузимся в эту тему поглубже.

В TypeScript можно определить собственные типы с помощью ключевого слова type . Рассмотрим простой пример:

type User = {
  id: number;
  name: string;
};

const user: User = {
  id: 1,
  name: "Alice",
};
Здесь User – это тип данных пользователя , который мы определили с помощью ключевого слова type . Он является структурой объекта с двумя полями: id , являющееся числом, и name , являющееся строкой.

Пользовательские типы могут быть более сложными и включать другие типы данных пользователя.

type Coordinate = [number, number];

type UserWithCoords = {
  id: number;
  name: string;
  coords: Coordinate;
};

const userWithCoords: UserWithCoords = {
  id: 1,
  name: 'Alice',
  coords: [10, 20],
};

export {};
В этом примере мы определили тип Coordinate как кортеж из двух чисел и затем использовали этот тип в определении другого типа, UserWithCoords .
<!-- Важные моменты
Кортежи: Тип Coordinate определяется как кортеж ([number, number]), что указывает на фиксированное количество элементов с определенными типами. Это полезно для представления пар значений, таких как координаты.
Композиция типов: Использование типа Coordinate внутри определения UserWithCoords демонстрирует композицию типов, где сложные типы создаются из более простых.
Проверка типов: TypeScript обеспечивает проверку типов, чтобы гарантировать, что объекты соответствуют ожидаемой структуре. В данном случае, если coords не будет массивом из двух чисел, TypeScript выдаст ошибку. -->

Давайте усложним пример еще больше. Воспользуемся enum как хранилищем ключей и опишем для каждого типа.

enum AnimalIds {
  cat = 'cat',
  dog = 'dog',
  fish = 'fish',
}

type Animal = {
  [AnimalIds.cat]: {
    meow: () => string;
  };
  [AnimalIds.dog]: {
    bark: () => string;
  };
  [AnimalIds.fish]: {
    swim: () => undefined;
  };
};

// Створення об'єктів типу Animal
let cat: Animal[AnimalIds.cat] = {
  meow: () => 'Meow! I am a cat',
};

let dog: Animal[AnimalIds.dog] = {
  bark: () => 'Woof! I am a dog',
};

let fish: Animal[AnimalIds.fish] = {
  swim: () => undefined,
};

export {};
В этом примере мы создали отдельные объекты для каждого животного, определенного в типе Animal . Каждый из этих объектов содержит функцию, соответствующую его типу ( meow для кошки, bark для собаки, swim для рыбы).



Важно отметить, что при создании этих объектов мы также использовали AnimalIds . В этом контексте это может показаться лишним, но представьте ситуацию, когда подобный код распределен по разным частям вашего проекта. В таких условиях, опираясь на enum , вы гарантированно выберите правильный тип данных. Эта конструкция не столь распространена, но имеет право на существование и может быть полезна в определенных сценариях.
